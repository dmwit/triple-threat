\documentclass{article}
\usepackage{fullpage}
\usepackage{amsmath,amssymb,amsfonts}

\title{Lens Examples for Locks and Constraints}
\date{}


\newcommand\Sum{\texttt{sum}}
\newcommand\Int{\texttt{int}}
\newcommand\Float{\texttt{float}}
\newcommand\F{\texttt F}
\newcommand\T{\texttt T}
\renewcommand\L{\texttt L}
\newcommand\R{\texttt R}
\newcommand\Fail{\texttt{fail}}

\newcommand\form[4]{#1 \rightarrow #2, #3 \qquad \qquad #4}

\begin{document}
\maketitle


\subsection*{Sums}

This section is motivated by the following example. We are given
sales data for a number of stores in a company, with 
each store identified by its state. The regional managers 
of the company can view the sum of their own region's sales 
data and change that number, indicating a wish to increase future
sales. If the manager wishes to change the sales figures from
$n$ to $N$, each store's figures will be multiplied by $\frac N n$
to make the change.
Similarly, the CEO can see the total sum of national
sales and adjust that number accordingly.  

%% Put diagram here

However, the sales data
for an individual store or region may be fixed or \emph{locked},
meaning that its sales data may not be changed.

On Notation: the lenses given here all have intuitive semantics in the 
``get'' direction, but in the ``put'' direction there is some
ambiguity. Therefore the examples detail only ``put'' behavior.
The put function of a lens takes (1) some input, (2) the current state of
the data, (3) some constraints on the data, and outputs either
failure or a new state. This is modeled using arrows:
\[ \form {\text{input}} {\text{current state}} {\text{constraints}} {\text{output}}.\]
When the state is a list of length $n$ and the constraint
on the data is that certain elements of the list may not change
in the output, we represent this \emph{locking constraint} as a boolean list
$O_1,\ldots,O_n$ of length $n$, where $O_i=T$ means the $i$th element
is locked, and $O_i=F$ otherwise. 

More general constraints are modeled as sets of feasible output.

\subsubsection*{Flat Sums}

We start with a lens which takes a single list of numbers
to its sum.
The default case, assuming no locks on the elements of the list,
distributes $n-\sum_{i=1}^m x_i$ among the list in proportion to
each $x_i$.
\begin{align}
    \form {200} {[10,20,30,40]} {\F\F\F\F} {[20,40,60,80]}
\end{align}

In the presence of locks on $\{x_j \mid j \in J\}$, we produce
a list which is the result of fixing the locked entries and 
distributing $n-\sum_{i=1}^m x_i$ values among the $m-|J|$ locked
elements of the list. 
\begin{align}
    \form {200} {[10,20,30,40]} {\T\F\F\F} {[10,42.2,63.3,84.4]}
\end{align}
To keep the first element of the list locked, we must scale
the other elements by a factor of $\frac {19} 9$. 

If the constraints do not allow the elements of the list
to be mutated to satisfy the sum, there are two possibilities
of output. The first option is to fail if the list cannot be mutated in-place.
\begin{align}
    \form {200} {[10,20,30,40]} {\T\T\T\T} {\Fail}
\end{align}
The second option is to add elements to the list so that the sum holds.
\begin{align}
    \form {200} {[10,20,30,40]} {\T\T\T\T} {[10,20,30,40,100]} 
\end{align}
In what context would this notion of sum be appropriate?

\subsubsection*{Split Sum}

Next we consider the lens which maps an ordered pair to
a labeled list, with each element of the list labeled 
as either \L (left) or \R (right). The left-labeled
elements of the list should sum up to the left element
of the ordered pair, and vice verse.

The default case with no locks behaves like an extension of the sum lens
above.
\begin{align}
    \form {(50,50)} {[\L10,\L20,\R30,\R40]} {\F\F\F\F} 
          {[\L16.67,\L33.33,\R21.43,\R28.57]}
\end{align}

Similarly, with the case for locks\ldots
\begin{align}
    \form {(50,50)} {[\L10,\L20,\R30,\R40]} {\T\F\F\T} 
          {[\L10,\L40,\R10,\R40]}
\end{align}

If locks prevent us from mutating either section of
the list to fit the constraint, we default to the options 
presented for plain sums in this situation.
\begin{align}
    \form {(50,70)} {[\L10,\L20,\R30,\R40]} {\T\T\F\F} {\Fail}
\end{align}
\begin{align}
    \form {(50,70)} {[\L10,\L20,\R30,\R40]} {\T\T\F\F} 
          {[\L10,\L20,\L20,\R30,\R40]}
\end{align}

\subsubsection*{Multi-Level Lenses}
We can represent the full sales example described in the beginning of
this section as a lens with multiple levels. From the CEO's point of
view, this lens stretches between the total sales data and a labeled
list of store sales data. 

When neither intermediary region is completely locked, a change from
$n$ to $N$ first scales up the intermediary regions by a factor of
$N/n$. The changes to each individual region must be accounted for,
even if some of its sub-elements are locked.
\begin{align}
    \form {200} {(30,70),[\L10,\L20,\R30,\R40]} {\T\F\F\F} 
          {(60,140),[\L10,\L50,\R60,\R80]}
\end{align}

When an entire region is locked however, we must propagate the locks
up to the regional level.
\begin{align}
    \form {200} {(30,70),[\L10,\L20,\R30,\R40]} {\T\T\F\F}
          {(30,170),[\L10,\L20,\R72.9,\R97.1]}
\end{align}

\subsection*{Cumulative Average}

A student is given some number of grades in a class, and she wants
to know what grades she needs to get in the future to obtain 
a desired average. The constraints on this problem may go beyond
locking to illuminate different environments. 

Given that all grades fall within a certain range, how many assignments
must the student complete to raise her average?
\begin{align}
    \form {95} {[80,100]} 
    {\{\text{lists like $[80,100,x_0,x_1,x_2,\ldots]$ where
      $0 \le x_i \le 100$}\}}
    {[80,100,100,100]}
\end{align}

The constraint might limit the number of future assignments.
\begin{align}
    \form {95} {[80,100]} 
    {\{\text{lists like $[80,100,x_0,\ldots,x_{n-1}]$ where
      $0 \le x_i \le 100$ and $n\le1$}\}}
    {\Fail}
\end{align}

\subsection*{Partition}

Constraints on the partition lens can be stated in a very general form,
and might be able to guide the lens's alignment/update policy. 
Let $A$, $B$ and $C$ be the following lists:
\begin{center} \begin{tabular}{l l | l | l}
    $A$ & &$B$ &$C$ \\
    \hline
    \L &Bach &Bach &Asimov\\
    \R &Asimov &Beethoven &Austen\\
    \L &Beethoven & &
\end{tabular} \end{center}
For example, we can use the constraint to model the structure
of the merge.
\begin{align}
    \form {B,C} {A} {\{\text{lists with authors first}\}} {~} 
    \begin{tabular}{l l}
        \R &\text{Asimov} \\
        \R &\text{Austen} \\
        \L &\text{Bach} \\
        \L &\text{Beethoven}
    \end{tabular}
\end{align}
\begin{align} 
    \form {B,C} {A} {\{\text{lists like $A\texttt{++}Z$
           where elements in $Z$ do not appear in $A$}\}} {~} 
    \begin{tabular}{l l}
        \L &\text{Bach} \\
        \R &\text{Asimov} \\
        \L &\text{Beethoven} \\
        \R &\text{Austen} 
    \end{tabular}
\end{align}

\subsection*{Database Operations}

In certain contexts, it might be valuable to view operations on relational
databases as lenses. Though good practice in relational database
design specifies that databases should not hold overlapping content,
in actuality it might be convenient to have two perminant tables
which share some information. These must both be able to be updated
independently, and their updates propogated to the other table.

We can represent get functions by SELECT INTO statements
and put functions by UPDATE statements, which take the old state of the
table into account. WHERE clauses represent constraints we have on the lenses. 
In the previous examples, the constraints modify the \emph{value} of the update.
Here, the constraints modify the \emph{range} of the update. 
Are these the constraints that we want, or are they just
generalized lenses?

\subsubsection*{Select}

Let's start with a simple SELECT statement example.
Let \textsc{jobs} be the following table, describing the jobs of employees
at a company.
\begin{center} \begin{tabular} {c | c c c}
    \textsc{jobs} & id & name & title \\
    \hline
    & 1 & Adam Aardvark & CEO \\
    & 2 & Brian Badger & VP of Sales \\
    & 3 & Charlie Camel & VP of Engineering \\
    & 4 & Diane Duck & Software Engineer
\end{tabular} \end{center}
A simple select statement picks out the name of the CEO.
\begin{quote}
    SELECT name \\
    INTO \textsc{ceo} \\
    FROM \textsc{jobs} \\
    WHERE title=`CEO'
\end{quote}
This produces a table \textsc{ceo} as follows:
\begin{center} \begin{tabular} {c | c}
    \textsc{ceo} & name\\
    \hline
    & Adam Aardvark
\end{tabular} \end{center}
Suppose Adam gets married and wants to change his name to a
hyphenated version. The following query updates the \textsc{ceo} table:
\begin{quote}
    UPDATE \textsc{ceo} \\
    SET name=Adam Aardvark-Albatross
\end{quote}
The result is the following updated table:
\begin{center} \begin{tabular} {c | c}
    \textsc{ceo} & name\\
    \hline
    & Adam Aardvark-Albatross
\end{tabular} \end{center}
The putback function uses the same constraint to update the \textsc{jobs}
table as it used to select into the \textsc{ceo} table. It
is not clear that the constraint should always be the same in the put direction
as it is in the get direction, as we see in the upcoming join example.
\begin{quote}
    UPDATE \textsc{jobs} \\
    SET name = \textsc{ceo}.name \\
    WHERE title = `CEO' 
\end{quote}
The result is the following:
\begin{center} \begin{tabular} {c | c c c}
    \textsc{jobs} & id & name & title \\
    \hline
    & 1 & Adam Aardvark-Albatross & CEO \\
    & 2 & Brian Badger & VP of Sales \\
    & 3 & Charlie Camel & VP of Engineering \\
    & 4 & Diane Duck & Software Engineer
\end{tabular} \end{center}

\subsubsection*{Join}

Consider the JOIN operation as a function from a pair of tables to a single
table. We might also want to move from a single table back to the 
separate pairs. Let's start with two tables, \textsc{jobs} as before,
and \textsc{bosses} which gives the id numbers of employees and their bosses.
\begin{center} \begin{tabular} {c | c c c}
    \textsc{jobs} & id & name & title \\
    \hline
    & 1 & Adam Aardvark & CEO \\
    & 2 & Brian Badger & VP of Sales \\
    & 3 & Charlie Camel & VP of Engineering \\
    & 4 & Diane Duck & Software Engineer
\end{tabular} \end{center}
\begin{center} \begin{tabular} {c | c c }
    \textsc{bosses} & id & boss\_id \\
    \hline
    & 1 & 1 \\
    & 2 & 1 \\
    & 3 & 1 \\
    & 4 & 3 
\end{tabular} \end{center}
Using the JOIN operation, we can write the following query which lists 
the names of employees along with the names of their boss.
\begin{quote}
    SELECT J1.name, J2.name \\
    INTO \textsc{named\_bosses} \\
    FROM \textsc{jobs} J1 JOIN \textsc{bosses} B JOIN \textsc{jobs} J2 \\
    ON J1.id = B.id AND B.boss\_id=J2.id
\end{quote}
The result is the following:
\begin{center} \begin{tabular} {c | c c }
    \textsc{named\_bosses} & name & boss\_name \\
    \hline
    & Adam Aardvark & Adam Aardvark \\
    & Brian Badger & Adam Aardvark \\
    & Charlie Camel & Adam Aardvark \\
    & Diane Duck & Charlie Camel
\end{tabular} \end{center}
If we change Diane Duck's boss to Brian Badger, we get
\begin{center} \begin{tabular} {c | c c }
    \textsc{named\_bosses} & name & boss\_name \\
    \hline
    & Adam Aardvark & Adam Aardvark \\
    & Brian Badger & Adam Aardvark \\
    & Charlie Camel & Adam Aardvark \\
    & Diane Duck & Brian Badger
\end{tabular} \end{center}
The change needs to be reflected back into the \textsc{bosses}
table (as, in this case, no change is made in \textsc{jobs}).
\begin{quote}
    UPDATE \textsc{bosses} \\
    FROM \textsc{jobs} J1 JOIN \textsc{named\_bosses} N JOIN \textsc{jobs} J2 \\
    ON J1.name = N.name AND N.boss\_name = J2.name \\
    SET B.boss\_id = J2.id \\
    WHERE B.id = J1.id
\end{quote}
Here, the putback operation's constraints do not match
the get operation's constraints; while before we matched
on id's, here we must match on names. 
However, the update results in the expected \textsc{bosses} table:
\begin{center} \begin{tabular} {c | c c }
    \textsc{bosses} & id & boss\_id \\
    \hline
    & 1 & 1 \\
    & 2 & 1 \\
    & 3 & 1 \\
    & 4 & 2 
\end{tabular} \end{center}


\end{document}
